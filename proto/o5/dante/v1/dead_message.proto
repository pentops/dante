syntax = "proto3";

package o5.dante.v1;

import "buf/validate/validate.proto";
import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";
import "o5/auth/v1/actor.proto";
import "o5/messaging/v1/message.proto";
import "o5/messaging/v1/topic/dead.proto";
import "psm/list/v1/annotations.proto";
import "psm/state/v1/annotations.proto";
import "psm/state/v1/metadata.proto";

option go_package = "github.com/pentops/dante/gen/o5/dante/v1/dante_pb";

message DeadMessageKeys {
  option (psm.state.v1.psm).name = "deadmessage";
  string message_id = 1 [
    (psm.state.v1.field).primary_key = true,
    (buf.validate.field).string.uuid = true
  ];
}

message DeadMessageState {
  psm.state.v1.StateMetadata metadata = 1 [(buf.validate.field).required = true];

  DeadMessageKeys keys = 2 [(buf.validate.field).required = true];

  MessageStatus status = 3 [(psm.list.v1.field).enum.filtering = {
    filterable: true,
    default_filters: ["MESSAGE_STATUS_CREATED"]
  }];

  DeadMessageData data = 4;
}

message DeadMessageData {
  DeadMessageNotification notification = 1;
  DeadMessageVersion current_version = 2;
}

message DeadMessageNotification {
  // Generated by the handler on failure, so that multiple failures of the same
  // message (either through replay or multiple services working on the same
  // cause) are not de-duplicated. This is used as the message_id on the wire
  // message when sent, the original message_id is in the message field.
  string death_id = 1 [(buf.validate.field).string.uuid = true];

  // The o5.application.name which attepmted to handle the message
  string handler_app = 2;

  // The o5.environment.full_name which attepmted to handle the message
  string handler_env = 3;

  // The message which was not able to be handled
  o5.messaging.v1.Message message = 4;

  // The problem which caused the message to die
  Problem problem = 5;
}

message DeadMessageVersion {
  string version_id = 1 [(buf.validate.field).string.uuid = true];
  o5.messaging.v1.Message message = 2;
}

message Problem {
  oneof type {
    option (psm.list.v1.oneof).filtering.filterable = true;

    InvariantViolation invariant_violation = 1;
    UnhandledError unhandled_error = 2;
  }
}

enum MessageStatus {
  MESSAGE_STATUS_UNSPECIFIED = 0;
  MESSAGE_STATUS_CREATED = 1;
  MESSAGE_STATUS_UPDATED = 2;
  MESSAGE_STATUS_REPLAYED = 3;
  MESSAGE_STATUS_REJECTED = 4;
}

enum Urgency {
  URGENCY_UNSPECIFIED = 0;
  URGENCY_LOW = 1;
  URGENCY_MEDIUM = 2;
  URGENCY_HIGH = 3;
}

message InvariantViolation {
  string description = 1 [(psm.list.v1.field).string.open_text.searching = {
    searchable: true
    field_identifier: "description"
  }];
  Any error = 2;
  Urgency urgency = 3 [(psm.list.v1.field).enum.filtering.filterable = true];
}

message UnhandledError {
  string error = 1 [(psm.list.v1.field).string.open_text.searching = {
    searchable: true
    field_identifier: "error"
  }];
}

// Any wraps the well-known any, but encodes messages as JSON in addition
message Any {
  google.protobuf.Any proto = 1;
  string json = 2;
}

message DeadMessageEvent {
  psm.state.v1.EventMetadata metadata = 1 [(buf.validate.field).required = true];

  DeadMessageKeys keys = 2 [(buf.validate.field).required = true];

  DeadMessageEventType event = 3 [(buf.validate.field).required = true];
}

message DeadMessageEventType {
  oneof type {
    option (psm.list.v1.oneof).filtering.filterable = true;

    Created created = 1;
    Updated updated = 2;
    Replayed replayed = 3;
    Rejected rejected = 4;
  }

  message Created {
    DeadMessageNotification notification = 1;
  }

  message Updated {
    DeadMessageVersion spec = 1;
  }

  message Replayed {}

  message Rejected {
    string reason = 1;
  }
}

message Metadata {
  string event_id = 1 [(buf.validate.field).string.uuid = true];

  google.protobuf.Timestamp timestamp = 2 [(buf.validate.field).required = true];

  o5.auth.v1.Actor actor = 3;
}
